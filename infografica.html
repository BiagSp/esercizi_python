<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Tuples in Python</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!--
    Chosen Palette: "Cool Blues" (Conceptual - using shades of blue and gray)
    Application Structure Plan:
    1.  Header: Title of the page.
    2.  Introduction: Brief explanation of Python tuples and their immutability.
    3.  Section 1: Creating Tuples.
        - Code example of tuple creation.
        -  Diagram placeholder for memory representation.
        -  Explanation of how variables reference tuples.
    4.  Section 2: Concatenating Tuples.
        - Code example of tuple concatenation.
        - Diagram placeholder showing new tuple creation.
        - Explanation of how concatenation works with immutable tuples.
    5.  Section 3: Tuples with Mutable Elements.
        - Code example demonstrating a tuple containing a list and modifying the list.
        - Diagram placeholder illustrating how the tuple's reference to the list remains, but the list's content changes.
        - Explanation of the distinction between immutable tuples and mutable elements within them.
    6.  Summary: Key takeaways.
    This structure provides a logical flow, starting with the basics and progressing to more complex concepts, making it easy for users to understand.

    Visualization & Content Choices:
    - Section 1 (Creating Tuples):
        - Goal: Inform about basic tuple creation and memory.
        - Viz/Presentation: Code block and a conceptual diagram (placeholder).
        - Interaction: None, purely informational.
        - Justification: Clearly show the initial state of a tuple in memory.
    - Section 2 (Concatenating Tuples):
        - Goal: Explain how concatenation affects tuples in memory.
        - Viz/Presentation: Code block and a conceptual diagram (placeholder).
        - Interaction: None, purely informational.
        - Justification: Illustrate that concatenation creates a new tuple, not modifies the original.
    - Section 3 (Tuples with Mutable Elements):
        - Goal: Demonstrate the behavior of mutable elements within immutable tuples.
        - Viz/Presentation: Code block and a conceptual diagram (placeholder).
        - Interaction: None, purely informational.
        - Justification: Clarify a common point of confusion regarding immutability.
    - All charts/diagrams are conceptual and will be represented by placeholders, as direct image generation is not feasible here. No external libraries like Chart.js or Plotly.js are needed for this specific request as it's more about conceptual diagrams.

    CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f0f4f8; /* Light, calm blue-gray background */
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #1e3a8a; /* Darker blue for main heading */
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            font-weight: 600;
        }
        h2 {
            color: #1e40af; /* A slightly lighter blue for subheadings */
            border-bottom: 2px solid #93c5fd; /* Light blue accent */
            padding-bottom: 8px;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.75em;
        }
        p {
            margin-bottom: 1.2em;
            font-size: 1.1em;
            color: #374151; /* Dark gray for text */
        }
        code.inline-code {
            background-color: #e0e7ff; /* Lighter blue for inline code */
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            color: #1d4ed8; /* Darker blue for code text */
        }
        .code-block {
            background-color: #f9fafb; /* Very light gray for code blocks */
            border: 1px solid #d1d5db; /* Light gray border */
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 20px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }
        .diagram-placeholder {
            background-color: #e5e7eb; /* Light gray background for placeholder */
            border: 2px dashed #9ca3af; /* Dashed border */
            padding: 20px;
            margin: 20px auto;
            text-align: center;
            font-style: italic;
            color: #4b5563; /* Darker gray text for placeholder */
            border-radius: 8px;
        }
        .note {
            background-color: #eff6ff; /* Light blue background for notes */
            border-left: 5px solid #3b82f6; /* Blue left border */
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .highlight {
            color: #1d4ed8; /* Blue for highlighting key terms */
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Understanding Tuple Immutability and Memory in Python</h1>

        <p>
            Tuples are a fundamental data structure in Python, known for being <strong>ordered</strong> and, crucially, <strong>immutable</strong>. This means that once a tuple is created, its contents—the items it holds—cannot be changed. You can't add new items, remove existing items, or modify items in place. This immutability has important implications for how Python manages memory for tuples and how operations like concatenation work.
        </p>

        <h2>1. Creating a Tuple</h2>
        <p>
            When you create a tuple in Python, the interpreter allocates a contiguous block of memory to store the elements of that tuple. The variable you assign the tuple to doesn't hold the tuple itself, but rather a <em>reference</em> (or a memory address) pointing to where the tuple's data is stored.
        </p>
        <p>
            Consider this example:
        </p>
        <pre class="code-block"><code>my_tuple = (10, 20, "hello")
print(my_tuple)
print(id(my_tuple))  # Prints the memory address (identity) of the tuple</code></pre>
        <p>
            In memory, this might look something like this:
        </p>
        <div class="diagram-placeholder">
            <p><strong>Memory Representation (Conceptual)</strong></p>
            <p><code>my_tuple</code> (Variable in current scope) ---&gt; [ Memory Address: 0x1000 ]</p>
            <p>At Memory Address 0x1000: <code>(10, 20, "hello")</code></p>
            <p>(Note: The actual memory address will be a large hexadecimal number.)</p>
        </div>
        <p>
            The variable <code class="inline-code">my_tuple</code> stores the memory address where the tuple <code>(10, 20, "hello")</code> is located.
        </p>

        <h2>2. Concatenating Tuples</h2>
        <p>
            Because tuples are immutable, when you "add" or concatenate two tuples, Python doesn't modify either of the original tuples. Instead, it creates an entirely <strong>new</strong> tuple in a new memory location. This new tuple contains all the elements from the first tuple followed by all the elements from the second.
        </p>
        <pre class="code-block"><code>tuple_a = (1, 2)
tuple_b = (3, 4)
new_tuple = tuple_a + tuple_b

print(f"tuple_a: {tuple_a}, id: {id(tuple_a)}")
print(f"tuple_b: {tuple_b}, id: {id(tuple_b)}")
print(f"new_tuple: {new_tuple}, id: {id(new_tuple)}")
</code></pre>
        <p>
            The output will show that <code>new_tuple</code> has a different memory address (ID) than <code>tuple_a</code> and <code>tuple_b</code>.
        </p>
        <div class="diagram-placeholder">
            <p><strong>Memory Representation (Concatenation)</strong></p>
            <p><code>tuple_a</code> ---&gt; [ Memory Address: 0x2000 | Content: (1, 2) ]</p>
            <p><code>tuple_b</code> ---&gt; [ Memory Address: 0x3000 | Content: (3, 4) ]</p>
            <p><code>new_tuple</code> ---&gt; [ Memory Address: 0x4000 | Content: (1, 2, 3, 4) ]</p>
            <p>(Addresses are illustrative)</p>
        </div>
        <p class="note">
            This behavior is different from list concatenation, where you can use methods like <code>.extend()</code> to modify a list in-place. With tuples, operations like <code>+</code> always result in a new tuple.
        </p>

        <h2>3. Tuples Containing Mutable Objects (e.g., Lists)</h2>
        <p>
            A crucial aspect of Python's data model is that variables (and elements within collections like tuples) store references to objects, not the objects themselves.
            If a tuple contains mutable objects, such as lists, the tuple itself remains immutable (you can't change which list it refers to), but the <em>content</em> of the mutable object (the list) can be changed.
        </p>
        <pre class="code-block"><code>my_list = [10, 20]
my_tuple_with_list = (1, my_list, 30)

print(f"Original tuple: {my_tuple_with_list}")
print(f"ID of my_tuple_with_list: {id(my_tuple_with_list)}")
print(f"ID of my_list: {id(my_list)}")
print(f"ID of element at index 1 in tuple: {id(my_tuple_with_list[1])}")

# Modify the list (which is an element of the tuple)
my_list.append(25)

print(f"Tuple after modifying the list: {my_tuple_with_list}")
print(f"ID of my_tuple_with_list (should be the same): {id(my_tuple_with_list)}")
print(f"ID of my_list (should be the same): {id(my_list)}")
print(f"ID of element at index 1 in tuple (still points to the same list): {id(my_tuple_with_list[1])}")

# Attempting to change the reference to the list within the tuple will fail:
# my_tuple_with_list[1] = [99, 100]  # This would raise a TypeError
</code></pre>
        <div class="diagram-placeholder">
            <p><strong>Memory Representation (Tuple with Mutable List)</strong></p>
            <p><code>my_list</code> ------------------------------------&gt; [Memory Address: 0x5000 | Content: [10, 20, 25]]</p>
            <p><code>my_tuple_with_list</code> ---&gt; [Memory Address: 0x6000 | Content: ( (ref to 1), (ref to 0x5000), (ref to 30) ) ]</p>
            <p>(The tuple stores a reference to the list object, not the list itself directly. So, when the list is modified, the tuple still points to the same list object, which has now changed.)</p>
        </div>
        <p>
            In this scenario, the tuple <code>my_tuple_with_list</code> still points to the same memory location. The second element of the tuple is a reference to the <code>my_list</code> object. When <code>my_list.append(25)</code> is executed, the list object itself is modified in its memory location. Since the tuple holds a reference to this list, the change is reflected when accessing the tuple. However, you cannot change the tuple to point to a *different* list.
        </p>

        <p class="note">
            Understanding this distinction is vital. The immutability of a tuple means its direct elements cannot be changed. If an element is a reference to a mutable object, that object can still be modified, but the reference itself within the tuple remains constant.
        </p>
    </div>
</body>
</html>